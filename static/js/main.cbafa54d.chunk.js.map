{"version":3,"sources":["resolvers/ingredient-search.js","IngredientSearch/ProductList.js","IngredientSearch/index.js","App.js","serviceWorker.js","index.js","assets/daily-harvest-logo.jpg"],"names":["resolveIngredientSearch","searchTerm","_searchTerm","trim","toLowerCase","searchIngredientIds","reduce","ingredients","result","ingredient","includes","name","push","id","filtered","forEach","products","product","_product","matchingIngredientsIds","intersection","ingredient_ids","length","ProductList","searchValue","buildIngredientListItems","map","ingredientId","find","getIngredientById","ingredientName","_searchValue","startIndex","indexOf","endIndex","prefixedText","substring","boldedText","postText","key","className","buildBoldedIngredient","productListItems","aria-label","DEFAULT_SEARCH_RESULTS","IngredientSearch","useState","loading","setLoading","setSearchValue","searchResults","setSearchResults","debouncedSearch","useRef","debounce","a","Promise","resolve","setTimeout","_searchResults","trailing","current","Fragment","placeholder","value","type","onChange","e","target","araia-label","AppLogo","src","logo","alt","App","fluid","justify","xs","sm","lg","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message","module","exports"],"mappings":"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","file":"static/js/main.cbafa54d.chunk.js","sourcesContent":["/**\r\n * Putting search logic in it's own file.  Ideally in a production environment, we would aim to do this search serverside with full text search support.\r\n */\r\nimport { products } from '../data/products.json'\r\nimport { ingredients } from '../data/ingredients.json'\r\nimport find from 'lodash/find'\r\nimport reduce from 'lodash/reduce'\r\nimport includes from 'lodash/includes'\r\nimport forEach from 'lodash/forEach'\r\nimport intersection from 'lodash/intersection'\r\n\r\n/**\r\n * resolveIngredientSearch\r\n * @param {String} searchTerm \r\n * \r\n * I decided to make the search function off an \"includes\" rather than strict equality.\r\n * This way, we can support partial matches.\r\n * If a user searches \"Organic\", they will see all results that contain \"organic\" anywhere in the ingredient name.\r\n */\r\nfunction resolveIngredientSearch(searchTerm) {\r\n  /**\r\n   * sanitize the input by trimming away any trailing spaces\r\n   * lowercase the input for text comparison so our search is case-insensitive\r\n   * technically this is a second trim() since the component already trimed the value on the component side...but wanted to keep this here to simulate a server environment\r\n   */\r\n  const _searchTerm = searchTerm.trim().toLowerCase()\r\n  \r\n  // Early out here for wher the user clears out the input\r\n  if (!_searchTerm) return []\r\n  \r\n  /**\r\n   * First we need to find the IDs of the ingredients that match the serach term\r\n   * Here we reduce the array of ingredient objects down to an array of ingredient IDs that match the search value\r\n   */\r\n  const searchIngredientIds = reduce(ingredients, (result, ingredient) => {\r\n    /**\r\n     * here im checking if the ingredient name includes our search term, remember to lowercase for case-insensitivity\r\n     * if the the includes passes, the ingredient ID is pushed on to the resulting array\r\n     */ \r\n    if (includes(ingredient.name.toLowerCase(), _searchTerm)) result.push(ingredient.id)\r\n    return result\r\n  }, [])\r\n\r\n  /**\r\n   * now that we have an array of ingredient IDs based off the users search,\r\n   * the last thing we need to do is filter the product data for those that included any of the IDs in the searchIngredientIds array\r\n   * if the intersection of product.ingredient_ids and searchResultIngredientIds is greater than 0,\r\n   * it means the product contains at least 1 matching ingredient, so return it in the result.\r\n   */\r\n  let filtered = []\r\n  forEach(products, product => {\r\n    // create a copy of the product as not to modify input parameter\r\n    const _product = { ...product }\r\n    // create the intersecting array\r\n    const matchingIngredientsIds = intersection(_product.ingredient_ids, searchIngredientIds)\r\n    /*\r\n     * saving off new array on product that represents which ingredients matched the users search\r\n     * I will later leverage this array to bolden the matching serch term in the UI\r\n     */ \r\n    _product.matchingIngredientsIds = matchingIngredientsIds\r\n\r\n    // return boolean to indicate if product should be included in filter\r\n    if (matchingIngredientsIds.length > 0) filtered.push(_product)\r\n  })\r\n\r\n  // return the filtered array\r\n  return filtered\r\n}\r\nexport default resolveIngredientSearch\r\n\r\n/**\r\n * getIngredientById\r\n * @param {Int} ingredientId \r\n * get the ingredient object by its ID\r\n */\r\nexport const getIngredientById = (ingredientId) => {\r\n  return find(ingredients, (ingredient) => ingredient.id === ingredientId)\r\n}","import React from 'react'\r\nimport includes from 'lodash/includes'\r\nimport { getIngredientById } from '../resolvers/ingredient-search'\r\n/**\r\n * \r\n * props {\r\n *   products: [Product],\r\n *   searchValue: String\r\n * } \r\n * \r\n * ProductList component is responsible for displaying a list of products.\r\n * It is fed an array of products to display in a list style fasion\r\n * It is also fed the users searchValue so it can bolden the matching search term\r\n * Right now it's still pretty ugly \r\n */\r\n\r\n// TODO: Would be really cool if we could render card style components with the Produce Name, Ingredient List, and some stock images of the Product.  But for now it's just some simple text results\r\nfunction ProductList ({ products, searchValue }) {\r\n  /**\r\n   * Builder function responsible for building the bolded ingredient text for search match\r\n   * @param { id: Int, name: String, is_allergen: Boolean } ingredient \r\n   * @param String searchValue \r\n   */\r\n  const buildBoldedIngredient = (ingredient, searchValue) => {\r\n    let ingredientName = ingredient.name.trim() // trimming this just in case there is bad data in the DB\r\n    let _searchValue = searchValue.trim() // trim the input from the user\r\n\r\n    const startIndex = ingredientName.toLowerCase().indexOf(_searchValue.trim().toLowerCase()) // find the starting index of the searchValue in the ingredient name\r\n    const endIndex = startIndex + _searchValue.length // find the endIndex by adding the length of the searchValue string\r\n\r\n    const prefixedText = ingredientName.substring(0, startIndex) // create a substring for any potential characters before the match\r\n    const boldedText = ingredientName.substring(startIndex, endIndex) // create a substring that is characters that match the search and thus should be bold\r\n    const postText = ingredientName.substring(endIndex, ingredientName.length) // create a substring for any potential characters after the match\r\n\r\n    // return the combined text\r\n    return (\r\n      <li key={`ingredient-${ingredient.id}`} className=\"Left\">\r\n        <span>{prefixedText}<b>{boldedText}</b>{postText}</span>\r\n      </li>\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Builder function to build the list items to display the products ingredients\r\n   * @param { id: Int, name: String, collection: String, ingredient_ids: [Int], matchingIngredientIds: [Int] } product \r\n   */\r\n  const buildIngredientListItems = (product) => {\r\n    return product.ingredient_ids.map(ingredientId => { // loop over products ingredients\r\n      const ingredient = getIngredientById(ingredientId) // get the ingredient by it's id\r\n      \r\n      if (!ingredient) return null // we could not find the given ingredient, skip it for now **come back to this if I have time, shouldn't ever occur since we are dealing with local data files**\r\n      \r\n      if (includes(product.matchingIngredientsIds, ingredientId)) { // check if the current ingredient is in the matching array\r\n        return buildBoldedIngredient(ingredient, searchValue)  // if it is, build bolded <li>\r\n      } else return <li key={ingredientId} className=\"Left\">{ingredient.name}</li> // else build regular <li>\r\n    })\r\n  }\r\n  \r\n  /**\r\n   * Build an array of <li> to be fed into the parent <ul>\r\n   * Each <li> represents a product\r\n   * Each product has it's own inner <ul> for it's ingredients\r\n   */\r\n  const productListItems = products.map(product => {\r\n    return (\r\n      <li key={`product-${product.id}`}>\r\n        <span>{product.name}</span> {/* display the product name */}\r\n        <ul>\r\n          {buildIngredientListItems(product)} {/* build the <li>s for the ingredient list */}\r\n        </ul>\r\n      </li>\r\n    )\r\n  })\r\n\r\n  // return the enture <ul> and it's child product <li>s\r\n  return (\r\n    <ul aria-label='product-list'>\r\n      {productListItems}\r\n    </ul>\r\n  )\r\n}\r\n\r\nexport default ProductList\r\n","import React, { useState, useRef } from 'react'\r\nimport { Row, Col } from 'react-grid-system';\r\nimport debounce from 'lodash/debounce'\r\nimport resolveIngredientSearch from '../resolvers/ingredient-search'\r\nimport ProductList from './ProductList'\r\n\r\nexport const DEFAULT_INGREDIENT_SEARCH = 'Organic Banana'\r\nexport const DEFAULT_PLACEHOLDER_TEXT = 'Hungry for ...'\r\nexport const DEFAULT_SIMULATED_NETWORK_DELAY_MILLISECONDS = 100\r\nexport const DEFAULT_DEBOUNCE_MILLISECONDS = 300\r\n\r\n/**\r\n * here i am running the search algorithm at bootstrap of the application.\r\n * this is done only to be technically correct in solving the problem,\r\n * that is, 'please write a program that returns all of the products that contain the ingredient \"Organic Banana\"'\r\n * in a real world scenario, we would probably just initialize the search to be empty\r\n */\r\nconst DEFAULT_SEARCH_RESULTS = resolveIngredientSearch(DEFAULT_INGREDIENT_SEARCH)\r\n\r\n/**\r\n * Main component that drives the search\r\n * Holds state for loading, user input, and search results\r\n * Renders and <input> and one of:\r\n *   loading indicator\r\n *   a no results message\r\n *   a <ProductList /> - React Component responsible for displaying a list of products\r\n */\r\nfunction IngredientSearch () {\r\n  const [loading, setLoading] = useState(false)  // initialize loading state to false\r\n  const [searchValue, setSearchValue] = useState(DEFAULT_INGREDIENT_SEARCH)  // initialize searchValue state to a default search term\r\n  const [searchResults, setSearchResults] = useState(DEFAULT_SEARCH_RESULTS) // initialize searchResults to the default results that were calculated at bootstrap of app\r\n  \r\n  /**\r\n   * Following block of code defines a function which I store to the variable titled debouncedSearch\r\n   * It is wrapped in a debounce, which makes it so we won't execute the search until the user done typing (currently 300ms)\r\n   * It also adds an artifical delay of DEFAULT_SIMULATED_NETWORK_DELAY to simulate the time it would take to fetch some data from a remote server (currently 100 ms) \r\n   */\r\n  const debouncedSearch = useRef(debounce(async (_searchValue) => {\r\n    await new Promise(resolve => setTimeout(resolve, DEFAULT_SIMULATED_NETWORK_DELAY_MILLISECONDS)) // artificial delay using Promise + setTimeout\r\n    const _searchResults = resolveIngredientSearch(_searchValue) // do the actual search\r\n    setSearchResults(_searchResults) // set the results to react state\r\n    setLoading(false) // set the loading to false\r\n  }, DEFAULT_DEBOUNCE_MILLISECONDS, {trailing: true})).current\r\n\r\n  /**\r\n   * onChange listener for input\r\n   * Sets the searchValue state to what the user typed in the input\r\n   * Invokes a delayedSearch with the trimmed serachValue\r\n   */\r\n  const handleInputChange = (e) => {\r\n    setLoading(true) // setting loading to true here to account for the debounce time as well as simulated network time\r\n    setSearchValue(e.target.value)  // set the searchValue state to the value of the <input>\r\n    debouncedSearch(e.target.value.trim()) // call our network simulated debouncedSearch with the trimmed input\r\n  }\r\n\r\n  /**\r\n   * Builder function that returns either:\r\n   *   a loading indicator\r\n   *     or\r\n   *   a message indicating no results\r\n   */\r\n  const buildLoadingOrNoResults = () => {\r\n    if (loading) return <Row><div className=\"Loader\"></div></Row>// if we are loading, then return the loader\r\n    if (searchValue && searchResults.length === 0) { // if loading is false, searchValue is defined (the user has entered text), and the result array is 0, then return a \"no results\" type of messaging\r\n      return (\r\n        <Row>\r\n          <Col>\r\n            <div araia-label='no-result-div' className=\"SorryMessage\">\r\n              <span>{`Sorry! Looks like we are fresh out of`}</span>\r\n              <br></br>\r\n              <span><i>{`\"${searchValue}\"`}</i></span>\r\n            </div>\r\n          </Col>\r\n        </Row>\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return JSX\r\n   * Tow Rows system\r\n   *   - first row is for the input\r\n   *   - second row is for the loading indicator, <ProductList />, or a \"no results\" style message\r\n   */\r\n  return (\r\n    <React.Fragment>\r\n      <Row>\r\n        <input aria-label='ingredient-search' className=\"SearchInput\" placeholder={DEFAULT_PLACEHOLDER_TEXT} value={searchValue} type='search' onChange={handleInputChange}></input>\r\n      </Row>\r\n      { \r\n        loading || searchResults.length === 0 ? buildLoadingOrNoResults() : <ProductList products={searchResults} searchValue={searchValue}/>\r\n      }\r\n    </React.Fragment>\r\n  )\r\n}\r\n\r\nexport default IngredientSearch","import './App.css'\nimport React from 'react'\nimport { Container, Row, Col } from 'react-grid-system';\nimport logo from './assets/daily-harvest-logo.jpg'\n\nimport IngredientSearch from './IngredientSearch'\n\n/**\n * Might not be completely necessary for this to be it's own React Component, but in a production environment we might need to do more with the logo like grab a URL from a remote\n */\nfunction AppLogo() {\n  return (\n    <Row>\n      <img className=\"AppLogo\" src={logo} alt=\"logo\" />\n    </Row>\n  )\n}\n\n/**\n   * App is built off a simple grid system.  Usually this is provided through an entire UI library suite such as Bootstrap\n   * Bringing in something like Bootstrap would give me a lot of stuff I do not need, so I found a nice grid system library to use instead\n   * https://github.com/sealninja/react-grid-system\n   * \n   * App renders The Daily Harvest logo and a React Component that handles the search and it's results\n   * \n   */\nfunction App() { \n  return (\n    <Container className='AppContainer' fluid>\n      <Row justify='center'>\n        {/* gutter */}\n        <Col xs={1} sm={3} lg={4}></Col>\n        <Col xs={10} sm={6} lg={4}>\n          <div>\n            <AppLogo />\n            <IngredientSearch />\n          </div>\n        </Col>\n        {/* gutter */}\n        <Col xs={1} sm={3} lg={4}></Col>\n      </Row>\n    </Container>\n  );\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/daily-harvest-logo.68c0e9f0.jpg\";"],"sourceRoot":""}